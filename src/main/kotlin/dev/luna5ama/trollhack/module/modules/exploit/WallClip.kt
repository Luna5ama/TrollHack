package dev.luna5ama.trollhack.module.modules.exploit

import dev.fastmc.common.TickTimer
import dev.fastmc.common.floorToInt
import dev.luna5ama.trollhack.event.SafeClientEvent
import dev.luna5ama.trollhack.event.events.PacketEvent
import dev.luna5ama.trollhack.event.events.TickEvent
import dev.luna5ama.trollhack.event.events.player.InputUpdateEvent
import dev.luna5ama.trollhack.event.events.player.PlayerMoveEvent
import dev.luna5ama.trollhack.event.events.render.Render3DEvent
import dev.luna5ama.trollhack.event.safeListener
import dev.luna5ama.trollhack.event.safeParallelListener
import dev.luna5ama.trollhack.graphics.ESPRenderer
import dev.luna5ama.trollhack.graphics.color.ColorRGB
import dev.luna5ama.trollhack.module.Category
import dev.luna5ama.trollhack.module.Module
import dev.luna5ama.trollhack.util.EntityUtils.betterPosition
import dev.luna5ama.trollhack.util.MovementUtils
import dev.luna5ama.trollhack.util.math.VectorUtils.setAndAdd
import dev.luna5ama.trollhack.util.world.getBlock
import dev.luna5ama.trollhack.util.world.hasCollisionBox
import net.minecraft.init.Blocks
import net.minecraft.network.play.client.CPacketPlayer
import net.minecraft.network.play.server.SPacketPlayerPosLook
import net.minecraft.util.math.BlockPos
import kotlin.math.max

internal object WallClip : Module(
    name = "Wall Clip",
    category = Category.EXPLOIT,
    description = "Automatically clips you into nearby wall to reduce damage",
    modulePriority = 9999
) {
    private val render by setting("Render", true)
    private val movementTimeout by setting("Movement Timeout", 1000, 0..5000, 50)
    private val interval by setting("Interval", 0, 0..5000, 50)

    private var fixTicks = -1
    private val enableTimer = TickTimer()
    private val clipTimer = TickTimer()

    private val offsets = doubleArrayOf(-0.15, -0.1, 0.0, 0.044)
    private val renderer = ESPRenderer().apply { aFilled = 63 }

    init {
        onEnable {
            fixTicks = -1
            enableTimer.reset(-114514)
        }

        safeListener<PacketEvent.PostReceive> {
            if (it.packet is SPacketPlayerPosLook) {
                fixTicks = 0
            }
        }

        safeListener<Render3DEvent> {
            if (render) {
                renderer.render(false)
            }
        }

        safeParallelListener<TickEvent.Post> {
            renderer.clear()
            if (!render) return@safeParallelListener

            val playerPos = player.betterPosition
            val pos = BlockPos.MutableBlockPos()

            fun addRenderer(pos: BlockPos) {
                if (world.getBlock(pos) == Blocks.BEDROCK) {
                    renderer.add(pos, ColorRGB(255, 0, 255))
                } else {
                    renderer.add(pos, ColorRGB(127, 0, 255))
                }
            }

            if (world.hasCollisionBox(pos.setAndAdd(playerPos, 1, 0, 0))) {
                addRenderer(pos)
            }
            if (world.hasCollisionBox(pos.setAndAdd(playerPos, 0, 0, 1))) {
                addRenderer(pos)
            }
            if (renderer.size == 0 && world.hasCollisionBox(pos.setAndAdd(playerPos, 1, 0, 1))) {
                addRenderer(pos)
            }
        }

        safeListener<InputUpdateEvent> {
            if (MovementUtils.isInputting(it.movementInput, jump = true, sneak = true)) {
                if (fixTicks != -1) {
                    it.movementInput.moveForward = 0.0f
                    it.movementInput.moveStrafe = 0.0f
                    it.movementInput.jump = false
                    it.movementInput.sneak = false
                    val posX = player.posX.floorToInt()
                    val posZ = player.posZ.floorToInt()
                    connection.sendPacket(
                        CPacketPlayer.Position(
                            posX + 0.7,
                            player.posY,
                            posZ + 0.7,
                            true
                        )
                    )
                    player.setPosition(posX + 0.6, player.posY, posZ + 0.6)
                }
                fixTicks = -1
                enableTimer.reset()
            }
        }

        safeListener<PlayerMoveEvent.Post>(Int.MIN_VALUE) {
            if (MovementUtils.isInputting(jump = true)) {
                enableTimer.reset()
                return@safeListener
            }

            if (!enableTimer.tick(movementTimeout)) return@safeListener
            if (!clipTimer.tick(interval)) return@safeListener

            if (fixTicks == -1) clipTimer.reset()

            val playerPos = player.betterPosition
            val pos = BlockPos.MutableBlockPos()

            var posX = player.posX
            var posZ = player.posZ

            val offset = offsets[max(fixTicks, 0)]
            val fixing = fixTicks < offsets.size - 1
            var collided = false

            val clipX = world.hasCollisionBox(pos.setAndAdd(playerPos, 1, 0, 0))
            val clipZ = world.hasCollisionBox(pos.setAndAdd(playerPos, 0, 0, 1))

            if (clipX) {
                collided = true
                posX = posX.floorToInt() + 0.7 + offset
            }

            if (clipZ) {
                collided = true
                posZ = posZ.floorToInt() + 0.7 + offset
            }

            if (!clipZ && !clipX && world.hasCollisionBox(pos.setAndAdd(playerPos, 1, 0, 1))) {
                collided = true
                posX = posX.floorToInt() + 0.7 + offset
                posZ = posZ.floorToInt() + 0.7 + offset
            }

            if (!collided) return@safeListener
            player.setPosition(posX, player.posY, posZ)

            if (fixing) {
                fixTicks++
                if (fixTicks == offsets.size - 1) {
                    connection.sendPacket(CPacketPlayer.Position(posX, player.posY, posZ, player.onGround))
                }
            }
        }
    }

    fun SafeClientEvent.isClipped(): Boolean {
        val boundingBox = player.entityBoundingBox
        return player.posX.floorToInt() != boundingBox.minX.floorToInt() ||
            player.posZ.floorToInt() != boundingBox.minZ.floorToInt()
    }
}