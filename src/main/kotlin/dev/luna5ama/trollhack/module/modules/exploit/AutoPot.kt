package dev.luna5ama.trollhack.module.modules.exploit

import dev.fastmc.common.TickTimer
import dev.luna5ama.trollhack.event.SafeClientEvent
import dev.luna5ama.trollhack.event.events.PacketEvent
import dev.luna5ama.trollhack.event.events.TickEvent
import dev.luna5ama.trollhack.event.events.WorldEvent
import dev.luna5ama.trollhack.event.events.player.OnUpdateWalkingPlayerEvent
import dev.luna5ama.trollhack.event.listener
import dev.luna5ama.trollhack.event.safeListener
import dev.luna5ama.trollhack.event.safeParallelListener
import dev.luna5ama.trollhack.manager.managers.EntityManager
import dev.luna5ama.trollhack.manager.managers.HotbarSwitchManager
import dev.luna5ama.trollhack.manager.managers.HotbarSwitchManager.ghostSwitch
import dev.luna5ama.trollhack.manager.managers.PlayerPacketManager
import dev.luna5ama.trollhack.manager.managers.PlayerPacketManager.sendPlayerPacket
import dev.luna5ama.trollhack.module.Category
import dev.luna5ama.trollhack.module.Module
import dev.luna5ama.trollhack.util.EntityUtils.isFakeOrSelf
import dev.luna5ama.trollhack.util.EntityUtils.isFriend
import dev.luna5ama.trollhack.util.accessor.entityID
import dev.luna5ama.trollhack.util.interfaces.DisplayEnum
import dev.luna5ama.trollhack.util.inventory.InventoryTask
import dev.luna5ama.trollhack.util.inventory.confirmedOrTrue
import dev.luna5ama.trollhack.util.inventory.hasPotion
import dev.luna5ama.trollhack.util.inventory.inventoryTask
import dev.luna5ama.trollhack.util.inventory.operation.swapWith
import dev.luna5ama.trollhack.util.inventory.slot.*
import dev.luna5ama.trollhack.util.math.vector.Vec2f
import dev.luna5ama.trollhack.util.world.getGroundLevel
import it.unimi.dsi.fastutil.ints.Int2LongOpenHashMap
import net.minecraft.entity.Entity
import net.minecraft.entity.projectile.EntityPotion
import net.minecraft.init.Items
import net.minecraft.init.MobEffects
import net.minecraft.inventory.Slot
import net.minecraft.network.play.client.CPacketPlayerTryUseItem
import net.minecraft.network.play.server.SPacketDestroyEntities
import net.minecraft.network.play.server.SPacketEntityStatus
import net.minecraft.potion.Potion
import net.minecraft.potion.PotionUtils
import net.minecraft.util.EnumHand
import kotlin.math.abs
import kotlin.math.sqrt

internal object AutoPot : Module(
    name = "Auto Pot",
    description = "药水哥",
    category = Category.EXPLOIT,
    modulePriority = 100
) {
    private val ghostSwitchBypass by setting("Ghost Switch Bypass", HotbarSwitchManager.Override.PICK)
    private val heal by setting("Heal", true)
    private val keepHealInHotbar by setting("Keep Heal Potion In Hotbar", true, ::heal)
    private val healHotbar by setting("Heal Potion Hotbar", 7, 1..9, 1, ::heal)
    private val healHealth by setting("Heal Health", 12.0f, 0.0f..20.0f, 0.5f, ::heal)
    private val healDelay by setting("Heal Delay", 500, 0..10000, 50, ::heal)
    private val weakness by setting("Weakness", false)
    private val weaknessFriendRange by setting("Weakness Friend Range", 5.0f, 0.0f..10.0f, 0.5f, ::weakness)
    private val weaknessRange by setting("Weakness Range", 1.8f, 0.0f..4.0f, 0.1f, ::weakness)
    private val weaknessDelay by setting("Weakness Delay", 1500, 0..10000, 50, ::weakness)
    private val speed by setting("Speed", true)
    private val speedDelay by setting("Speed Delay", 5000, 0..10000, 50, ::speed)

    private val weaknessTimeMap = Int2LongOpenHashMap().apply { defaultReturnValue(0x22) }
    private var currentPotion = PotionType.NONE

    private var lastTask: InventoryTask? = null

    override fun getHudInfo(): String {
        return currentPotion.displayString
    }

    init {
        onDisable {
            currentPotion = PotionType.NONE
            lastTask = null
        }

        listener<PacketEvent.PostReceive> {
            when (it.packet) {
                is SPacketDestroyEntities -> {
                    it.packet.entityIDs.forEach(weaknessTimeMap::remove)
                }
                is SPacketEntityStatus -> {
                    if (it.packet.opCode.toInt() == 35) {
                        weaknessTimeMap.remove(it.packet.entityID)
                    }
                }
            }
        }

        safeListener<WorldEvent.Entity.Remove> { event ->
            if (event.entity is EntityPotion) {
                val effect = PotionUtils.getEffectsFromStack(event.entity.potion)
                    .firstOrNull { it.potion == MobEffects.WEAKNESS } ?: return@safeListener

                val box = event.entity.entityBoundingBox.grow(4.0, 2.0, 4.0)

                EntityManager.players.asSequence()
                    .filter { it.isEntityAlive }
                    .filterNot { it.isFakeOrSelf }
                    .filterNot { it.isFriend }
                    .filter { box.intersects(it.entityBoundingBox) }
                    .forEach {
                        val distSq = event.entity.getDistanceSq(it)

                        if (distSq < 16.0) {
                            val factor = sqrt(distSq) * 0.75
                            val duration = (factor * effect.duration + 0.5)
                            weaknessTimeMap[it.entityId] = System.currentTimeMillis() + duration.toLong() * 50L
                        }
                    }
            }
        }

        safeListener<OnUpdateWalkingPlayerEvent.Pre> {
            if (!groundCheck()) {
                currentPotion = PotionType.NONE
                return@safeListener
            }

            if (currentPotion == PotionType.NONE) {
                currentPotion = PotionType.VALUES.first {
                    it.check(this)
                }
            }

            if (currentPotion != PotionType.NONE) {
                sendPlayerPacket {
                    rotate(Vec2f(player.rotationYaw, 90.0f))
                }
            }
        }

        safeListener<OnUpdateWalkingPlayerEvent.Post> {
            val potionType = currentPotion
            if (potionType == PotionType.NONE) return@safeListener
            if (PlayerPacketManager.prevRotation.y <= 85.0f || PlayerPacketManager.rotation.y <= 85.0f) return@safeListener

            getSlot(potionType)?.let {
                ghostSwitch(ghostSwitchBypass, it) {
                    connection.sendPacket(CPacketPlayerTryUseItem(EnumHand.MAIN_HAND))
                    potionType.timer.reset()
                    currentPotion = PotionType.NONE
                }
            }
        }

        safeParallelListener<TickEvent.Post> {
            if (!heal || !keepHealInHotbar) return@safeParallelListener
            if (player.hotbarSlots.hasPotion(PotionType.INSTANT_HEALTH)) return@safeParallelListener
            if (!lastTask.confirmedOrTrue) return@safeParallelListener
            if (currentPotion != PotionType.NONE && currentPotion != PotionType.INSTANT_HEALTH) return@safeParallelListener

            val slotFrom = player.allSlots.findPotion(PotionType.INSTANT_HEALTH) ?: return@safeParallelListener
            lastTask = inventoryTask {
                swapWith(slotFrom, player.hotbarSlots[healHotbar - 1])
                postDelay(100L)
                runInGui()
            }
        }
    }

    private fun SafeClientEvent.groundCheck(): Boolean {
        return player.onGround
            || player.posY - world.getGroundLevel(player) < 3.0
    }

    private fun SafeClientEvent.getSlot(potionType: PotionType): Slot? {
        return player.allSlotsPrioritized.findPotion(potionType)
    }

    private fun List<Slot>.findPotion(potionType: PotionType): Slot? {
        return this.asSequence()
            .filter {
                val stack = it.stack
                stack.item == Items.SPLASH_POTION && stack.hasPotion(potionType.potion)
            }.minByOrNull {
                if (it.isHotbarSlot) -1 else it.stack.count
            }
    }

    private fun List<Slot>.hasPotion(potionType: PotionType): Boolean {
        return hasItem(Items.SPLASH_POTION) { itemStack ->
            itemStack.hasPotion(potionType.potion)
        }
    }

    private enum class PotionType(override val displayName: CharSequence, val potion: Potion) : DisplayEnum {
        INSTANT_HEALTH("Heal", MobEffects.INSTANT_HEALTH) {
            override fun check(event: SafeClientEvent): Boolean {
                return heal
                    && timer.tick(healDelay)
                    && event.player.health <= healHealth
                    && super.check(event)
            }
        },

        WEAKNESS("Weakness", MobEffects.WEAKNESS) {
            override fun check(event: SafeClientEvent): Boolean {
                return weakness
                    && timer.tick(weaknessDelay)
                    && super.check(event)
                    && (weaknessFriendRange == 0.0f || EntityManager.players.asSequence()
                    .filterNot { it.isFakeOrSelf }
                    .filter { it.isFriend }
                    .all { event.player.getDistanceSq(it) > weaknessFriendRange * weaknessFriendRange })
                    && EntityManager.players.asSequence()
                    .filterNot { it.isFriend }
                    .filterNot { it.isFakeOrSelf }
                    .filter { event.isInRange(it) }
                    .any { !weaknessTimeMap.containsKey(it.entityId) }
            }

            private fun SafeClientEvent.isInRange(entity: Entity): Boolean {
                return abs(player.posX - entity.posX) <= 4.125
                    && abs(player.posY - entity.posY) <= 2.125
                    && abs(player.posZ - entity.posZ) <= 4.125
                    && player.getDistanceSq(entity) <= weaknessRange * weaknessRange
            }
        },

        SPEED("Speed", MobEffects.SPEED) {
            override fun check(event: SafeClientEvent): Boolean {
                return speed
                    && timer.tick(speedDelay)
                    && !event.player.isPotionActive(MobEffects.SPEED)
                    && super.check(event)
            }
        },

        NONE("", MobEffects.LUCK) {
            override fun check(event: SafeClientEvent): Boolean {
                return true
            }
        };

        val timer = TickTimer()

        open fun check(event: SafeClientEvent): Boolean {
            return event.player.allSlots.hasPotion(this)
        }

        companion object {
            @JvmField
            val VALUES = values()
        }
    }
}